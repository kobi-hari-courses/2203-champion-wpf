# Day 05 - More TPL and Mvvm
### Projects:
|     |     |
| --- | --- |
| [FunWithTpl](FunWithTpl/) | Introduction to Task Parallel Library |
| [FunWithMvvm](FunWithMvvm/) | Introduction to DI and techniques in MVVM |

# TPL
* We talked in more depth about `async-await`
  * What does `async void` mean
  * What does `async Task<T>` mean
  * What does an async method return
* We demonstrated how to do task cancallation
  * We understood that it is a mutual process where the running task needs to "agree" to cancel
  * We saw that canceling is done by throwing a `OperationCancelledException`
  * We saw that the way to request cancellation is by passing `CancellationToken` to the task
    * The task itself should check the token from time to time to see if it was triggered
    * The token is generated by a `CancellationTokenSource` instance that can be used to trigger the token
* We saw how to convert sequential algorithm to "functional" one and then run it in parallel using `PLINQ`
* We saw how to report progress using `IProgress<T>`
  * The task receives an `IProgress` and uses the `Report` method to report progress every once in a while
  * The caller creates an instance of `Progress<T>` that wraps a delegate that will be executed **in the calling thread**
* We saw how to create atomic completed tasks from scrarch
  * `Task.FromResult`
  * `Task.FromException`
  * `Task.FromCanceled`
  * `Task.CompletedTask`
* We saw how to create a task that delays asynchronously
  * `Task.Delay`
* We saw how to combine tasks together
  * `Task.WhenAll`
  * `Task.WhenAny`
* Finally we saw an example of how to use `TaskCompletionSource` to control our own `Task`
  * We also used `CancellationToken.Register` to register a callback that will cancel the task if required.

# Blendable MVVM
* We saw how to create a view model base in .net core
* We saw how to inject design time view model into the view using `d:DataContext` and `{d:DesignData}`

# Depndency Injection in .net Core
* We understood why it is important to use .net core dependency injection
* We understood the meaning of `IServiceCollection` and `IServiceProvider`
* We talked about the 3 possible lifecycles
  * Singletons
  * Transient
  * Scoped
* We saw how to create services and register them in the service collection
* We saw how to create a view model using the container
* We created different ctors for Design time and Runtime



  







  
